import logging
import dashscope
from dashscope import Generation
from capstone import *
import numpy as np
from typing import Dict, Any
from model_handler import ModelHandler


class VulnerabilityAnalyzer:
    """漏洞检测核心模块（支持多模型）"""

    def __init__(self, model_type: str = "deepseek", api_key: str = None):
        self.model_handler = ModelHandler(api_key=api_key, default_model=model_type)
        self.md = Cs(CS_ARCH_X86, CS_MODE_64)

    def _init_model(self, model_type: str, api_key: str) -> Any:
        """初始化大模型接口（工厂模式）"""
        if model_type == "qwen":
            return QWenAnalyzer(api_key)
        elif model_type == "deepseek":
            return DeepSeekAnalyzer(api_key)
        else:
            raise ValueError(f"Unsupported model type: {model_type}")

    def analyze(self, binary_path: str) -> Dict:
        """执行漏洞检测流程"""
        try:
            # 反汇编处理
            disasm = self._advanced_disassembly(binary_path)

            # 特征提取
            features = self._extract_security_features(disasm)

            # 统一模型调用
            prompt = self._build_prompt(features)
            report = self.model_handler.generate_analysis(prompt)

            return {
                "status": "success",
                "features": features,
                "report": report
            }
        except Exception as e:
            logging.error(f"漏洞检测失败: {str(e)}")
            return {"status": "error", "message": str(e)}

    def _advanced_disassembly(self, binary_path: str) -> Dict:
        """增强型反汇编处理（参考BinML论文方法）"""
        with open(binary_path, 'rb') as f:
            code = f.read()

        instructions = list(self.md.disasm(code, 0x1000))
        # 控制流特征提取
        cfg = []
        api_calls = []

        for insn in self.md.disasm(code, 0x1000):
            # 识别跳转指令
            if insn.mnemonic.startswith('j'):
                cfg.append({
                    "address": insn.address,
                    "type": "branch",
                    "target": int(insn.op_str.split()[0], 16)
                })
            else:
                cfg.append({
                    "address": insn.address,
                    "type": "normal"
                })

        # 危险API模式识别（示例）
            dangerous_apis = ["strcpy", "system", "gets"]
            if insn.mnemonic == "call" and any(api in insn.op_str for api in dangerous_apis):
                api_calls.append(insn.address)

        return {
            "raw_bytes": code,
            "instructions": instructions,
            "raw_disasm": "\n".join(f"0x{insn.address:x}: {insn.mnemonic} {insn.op_str}" for insn in instructions),
            "control_flow": cfg,
            "dangerous_calls": api_calls
        }

    def _extract_security_features(self, disasm: Dict) -> Dict:
        """提取安全特征（参考VulDeePecker方法）"""
        instructions = disasm["instructions"]
        # 1. API调用序列
        api_seq = [
            insn.op_str.split(';')[-1].strip()
            for insn in instructions
            if insn.mnemonic == "call"
        ]

        # 2. 内存操作统计
        mem_ops = {
            "malloc": 0,
            "free": 0,
            "buffer_access": 0
        }
        for insn in instructions:
            op_str = insn.op_str
            if "malloc" in op_str:
                mem_ops["malloc"] += 1
            elif "free" in op_str:
                mem_ops["free"] += 1
            if any(reg in insn.op_str for reg in ["[rbp", "[rsp"]):
                mem_ops["buffer_access"] += 1

        # 3. 控制流复杂度
        cfg_complexity = len([n for n in disasm["control_flow"] if n["type"] == "branch"])

        return {
            "api_sequence": api_seq,
            "memory_operations": mem_ops,
            "cfg_complexity": cfg_complexity,
            "dangerous_calls": len(disasm["dangerous_calls"])
        }

    def _build_prompt(self, features: Dict) -> str:
        """统一提示词构造（核心方法）"""
        return f"""二进制安全分析请求（模型: {self.model_handler.default_model}）：

        ## 安全特征
        1. 危险API调用次数：{features['dangerous_calls']}
        2. 内存操作统计：
           - malloc: {features['memory_operations']['malloc']}
           - free: {features['memory_operations']['free']}
           - 缓冲区访问: {features['memory_operations']['buffer_access']}
        3. 控制流复杂度：{features['cfg_complexity']}

        ## 分析要求
        - 按可能性降序列出前3个漏洞类型
        - 每个漏洞需包含：
          * 风险等级评估（高/中/低）
          * 关键指令地址
          * 修复建议"""

class BaseModelAnalyzer:
    """大模型接口基类（便于扩展）"""

    def generate_vuln_report(self, features: Dict) -> str:
        raise NotImplementedError


class QWenAnalyzer(BaseModelAnalyzer):
    def __init__(self, api_key: str):
        dashscope.api_key = api_key

    def generate_vuln_report(self, features: Dict) -> str:
        """生成通义千问格式的漏洞报告"""
        prompt = self._build_prompt(features)
        try:
            response = Generation.call(
                model='qwen-max',
                prompt=prompt,
                max_length=2000,
                temperature=0.3
            )
            return response.output.text
        except Exception as e:
            logging.error(f"QWen API调用失败: {str(e)}")
            return "分析服务暂不可用"




class DeepSeekAnalyzer(BaseModelAnalyzer):
    def __init__(self, api_key: str):
        # DeepSeek的初始化逻辑（示例）
        self.api_key = api_key

    def generate_vuln_report(self, features: Dict) -> str:
        """DeepSeek实现（接口示例）"""
        # 实际需要根据DeepSeek的API文档实现
        return "DeepSeek分析报告（示例）"